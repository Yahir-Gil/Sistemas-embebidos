{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"Lab_01-03/","title":"Lab 01","text":""},{"location":"Lab_01-03/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li>Understand FreeRTOS task creation and scheduling.</li> <li>Implementar el control de GPIO para el parpadeo de un LED en ESP32.</li> <li>Gestionar retardos de tiempo usando la funci\u00f3n vTaskDelay.</li> <li>Configurar correctamente las prioridades y tama\u00f1os de stack de las tareas.</li> </ul>"},{"location":"Lab_01-03/#2-materials","title":"2) Materials","text":"<p>No materials required </p>"},{"location":"Lab_01-03/#3-code","title":"3) Code","text":""},{"location":"Lab_01-03/#this-code-of-lab-01","title":"This code of LAb 01","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Lab_01-03/#code-of-exercise-lab-01","title":"Code of exercise Lab 01","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   \n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // blink_task prioridad esta mas alta\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n\n    // hello_task prioridad baja (antes era 5)\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n}\n</code></pre>"},{"location":"Lab_01-03/#4-procedure","title":"4) Procedure","text":""},{"location":"Lab_01-03/#exercises","title":"Exercises","text":"<ul> <li>Priority experiment: change hello_task priority from 5 to 2.</li> </ul> <p>The code takes how more important task with lower number, so the code does first that task and continue with the code. </p> <ul> <li>Does behavior change? Why might it (or might it not)? Yes, how we changed the priority, the blinking task goes after the oanother task.</li> </ul> <p>Starvation demo: temporarily remove vTaskDelay(...) from hello_task.</p> <ul> <li>What happens to blinking?</li> </ul> <p>The sistem never will be blocked and then the task always will be ready, for this the hello task  saturates the CPU, that we can see like a bottleneck. For this the led doesn't blinking. </p> <ul> <li>Put the delay back and explain in one sentence why blocking helps.</li> </ul> <p>The led will be blinking again each 300 ms and the serial monitor mesaages will be each 1 s. </p>"},{"location":"Lab_01-03/#this-code-of-lab-02","title":"This code of LAb 02","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Lab_01-03/#code-of-exercise-lab-02","title":"Code of exercise Lab 02","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        // Producer m\u00e1s r\u00e1pido\n        vTaskDelay(pdMS_TO_TICKS(20));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n\n            // Consumer lento\n            vTaskDelay(pdMS_TO_TICKS(300));\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    // Queue m\u00e1s grande\n    q_numbers = xQueueCreate(20, sizeof(int));\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Lab_01-03/#exercises_1","title":"Exercises","text":"<ul> <li>Make the producer faster: change producer delay 200ms \u2192 20ms.</li> </ul> <p>With this change the producer is generating each 20 ms but the cinsumer no, the consumer only is waiting to the producer.  * When do you see \u201cQueue full\u201d?</p> <p>That we can see when the producer is trying to give data faster than the consumer can processing. This because the consumer is lower than producer and the spaces will be loaded. </p> <ul> <li>Increase the queue length 5 \u2192 20.</li> <li>What changes?</li> </ul> <p>With this we can see that the consumer has more spaces for store data, after load those 20 spaces, the consumer will star to lost data.</p> <ul> <li>Make the consumer \u201cslow\u201d: after a successful receive, add:      vTaskDelay(pdMS_TO_TICKS(300));,  What pattern is happening now (buffering / backlog)?</li> </ul> <p>Whit this code we can see that the system in the first seconds the producer will loaded the 20 spaces of the quue, so the consumer is lower for that will be proccesing the data 1 while the producer has already sent 2, 3, 4, ... Therefore our queue will always be full because since the consumer takes 300ms to process a single piece of data, and in that time the producer tried to send 15 new pieces of data (300 / 20 = 15).</p>"},{"location":"Lab_01-03/#this-code-of-lab-03","title":"This code of LAb 03","text":"<p><pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> * Part A: Why can the counter be wrong? Task A copies the counter value to its local memory.</p> <p>The system is pausing Task A before it finishes and gives Task B its turn. That's why Task B reads the same 100, increments it to 101, and stores it. When Task A returns, it still thinks the value is 100, increments it to 101, and stores it over Task B's value. Two increments were made, but the counter only increased by 1. Information was \"lost\" along the way.</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#define LED_GPIO GPIO_NUM_2   \n#define BUTTON5_GPIO  GPIO_NUM_3\nint Read_button5 = 0; // Aqu\u00ed guardamos la lectura\n\nvoid read_button_task5(void *pvParameters)\n{\n    gpio_set_direction(BUTTON5_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON5_GPIO, GPIO_PULLUP_ONLY);\n  print(my name is isaac_rec.name)\n\n    while (1) {\n        Read_button5 = gpio_get_level(BUTTON5_GPIO);\n        vTaskDelay(pdMS_TO_TICKS(20)); // cada 20ms\n    }\n}\n    while (1) {\n        Read_button5 = gpio_get_level(BUTTON5_GPIO);\n        vTaskDelay(pdMS_TO_TICKS(20)); // cada 20ms\n    }\n}\n// TAG para los mensajes del log (ESP_LOGI)\nstatic const char *TAG = \"LAB3A\";\nstruct patient{\n    int counter=0;\n    char[10] name=\"\";\n};\n\n}\nstatic void HEARTBEAT(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void Alive(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"Alive, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    struct patient isaac_sends;\n    isaac_sends.name = \"isaac\"\n\n    while (1) {\n        isaac_sends.counter=isaac.counter+1;\n\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;isaac, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    struct patient isaac_rec;\n\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;isaac_rec, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n            print(my name is isaac_rec.name and im counting to isaac_rec.counter)\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(7, sizeof(counter)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;//crash m rogram\n    }\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    // Crea varias tareas que compiten por incrementar shared_counter.\n    // 1 tarea \"TaskA\"\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n\n    // 4 tareas \"TaskB\" (todas compiten tambi\u00e9n por el mismo contador)\n    // OJO: todas tienen el mismo nombre de task (\"incB\") y el mismo par\u00e1metro \"TaskB\".\n    // Esto dificulta distinguirlas en depuraci\u00f3n.\n    xTaskCreate(HEARTBEAT, \"blink_task\", 2048, \"TaskA\", 1, NULL);\n    xTaskCreate(Alive, \"Alive\", 2048, \"TaskB\", 2, NULL);\n    xTaskCreate(producer_task, \"TaskC\", 2048, NULL, 3, NULL);\n    xTaskCreate(consumer_task, \"TaskD\", 2048, NULL, 4, NULL);\n    xTaskCreate(read_button_task5, \"incE\", 2048, \"Task5\", 5, NULL);\n    xTaskCreate( read_button_task6, \"incF\", 2048, \"Task6\", 6, NULL);\n\n}\n</code></pre>"},{"location":"Lab_01-03/#exercises_2","title":"Exercises","text":"<ul> <li>Remove the mutex again. Do you ever see weird behavior?</li> </ul> <p>Yes, the counter will grow slower than expected or show inconsistent values.</p> <ul> <li>Change priorities: TaskA priority 6, TaskB priority 4. What do you expect and why?</li> </ul> <p>La Tarea A interrumpir\u00e1 a la Tarea B casi siempre que termine su tiempo de espera.</p> <ul> <li>In one sentence: what does a mutex \u201cguarantee\u201d?</li> </ul> <p>A mutex guarantees that only one task can access a shared resource at any given time.</p>"},{"location":"Lab_01-03/#extra-mini-challenges","title":"Extra mini-challenges","text":"<ul> <li>Heartbeat + work task</li> <li>Add a third task that prints \u201calive\u201d every 2 seconds.</li> <li>Queue with struct</li> <li>Send a struct: {int id; int value;}</li> <li>Mutex around a shared peripheral</li> <li>Make two tasks write to the same log message format (simulate \u201cshared UART resource\u201d) and guard it with a mutex.</li> </ul>"},{"location":"Lab_01-03/#5-results","title":"5) Results","text":""},{"location":"Lab_01-03/#labs-codes-running","title":"Labs codes running","text":"<p>Enlace directo</p> <p>Enlace directo</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}